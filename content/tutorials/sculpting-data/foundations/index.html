---
title: "Part I — Foundations of Form"
layout: "tutorial"
---

<!-- =======================  PART I HEADER  ======================= -->

<h3>How to Use This</h3>
<p>Each section begins with <code>Tutorial:</code> — run the snippet first.<br>
Deep-dive panels are optional.<br>
End with <strong>Try It → Recap</strong> to consolidate.</p>


<h3>What You'll Learn</h3>
<ul>
<li>How data behaves as material</li>
<li>Containers → Buffers → Streams</li>
<li>Cycle-based timing & deterministic flow</li>
<li>How structure produces form in MayaFlux</li>
</ul>

<hr>

<!-- =======================  TUTORIAL SECTION 1 ======================= -->

<section class="tutorial-section">

    <div class="tutorial-row">

        <div class="tutorial-card" data-target="first-expanded">
            <h3 class="tutorial-title">Tutorial: The Simplest First Step</h3>
            <p class="hint">Click this card to reveal full explanation</p>

            <p>Run this code. The file is loaded into memory.</p>

            <pre><code class="language-cpp">
// In your src/user_project.hpp compose() function:

void compose() {
    auto sound_container = vega.read_audio("path/to/your/file.wav");
}
            </code></pre>

            <p>Replace "path/to/your/file.wav" with an actual path to a .wav file.</p>

            <p>Run the program. You'll see console output showing what loaded:</p>

            <pre><code class="language-text">✓ Loaded: path/to/your/file.wav
  Channels: 2
  Frames: 2304000
  Sample Rate: 48000 Hz
            </code></pre>

            <p>Nothing plays yet. That's intentional—and important. The rest of this section shows you what just happened.</p>

            <p>You have:</p>
            <ul>
                <li>All audio data in memory</li>
                <li>Organized as a Container with metadata</li>
                <li>A processor attached, ready to chunk and feed data</li>
                <li>Full control over what happens next</li>
            </ul>

            <p>The file is loaded. Ready. Waiting.</p>
        </div>

    </div>

</section>


<!-- =======================  EXPANSION SECTION 1 ======================= -->

<section id="first-expanded" class="tutorial-expanded">

    <h2>Expansion 1: What Is a Container?</h2>

    <details>
        <summary></summary>

        <p>When you call <code>vega.read_audio()</code>, you're not just reading bytes from disk and forgetting them. You're creating a <strong>Container</strong>—a structure that holds:</p>

        <ul>
            <li><strong>The audio data itself</strong> (all samples as numbers, deinterleaved and ready to process)</li>
            <li><strong>Metadata about the data</strong> (sample rate, channels, duration, number of frames)</li>
            <li><strong>A processor</strong> (machinery that knows how to access this data efficiently)</li>
            <li><strong>Organizational structure</strong> (dimensions: time, channels, memory layout)</li>
        </ul>

        <p>The difference: A file is <strong>inert</strong>. A Container is <strong>active creative material</strong>. It knows its own shape. It can tell you about regions within itself. It can be queried, transformed, integrated with other Containers.</p>

        <p>When <code>vega.read_audio("file.wav")</code> runs, MayaFlux:</p>

        <ol>
            <li>Creates a <code>SoundFileReader</code> and initializes FFmpeg</li>
            <li>Checks if the file is readable</li>
            <li>Resamples to your project's sample rate (configurable)</li>
            <li>Converts to 64-bit depth (high precision)</li>
            <li><strong>Deinterleaves</strong> the audio (separates channels into independent arrays—more efficient for processing)</li>
            <li>Creates a <code>SoundFileContainer</code> object</li>
            <li>Loads all the audio data into memory</li>
            <li>Configures a <code>ContiguousAccessProcessor</code> (the Container's default processor, which knows how to feed data to buffers chunk-by-chunk)</li>
            <li>Returns the Container to you</li>
        </ol>

        <p>The Container is now your interface to that audio data. It's ready to be routed, processed, analyzed, transformed.</p>

    </details>


    <h2>Expansion 2: Memory, Ownership, and Smart Pointers</h2>

    <details>
        <summary></summary>

        <p>As you know, raw audio data can be large. MayaFlux allocates and manages it safely through smart pointers.</p>

        <p>At a lower, machine-level (in programming parlance), the user is expected to manage memory manually: instantiate objects, bind them, handle transfers, and delete when done. Any misalignment among these steps can cause crashes or undefined behavior. MayaFlux doesn't expect you to handle these manually—unless you choose to.</p>

        <p>MayaFlux uses <strong>smart pointers</strong>—a C++11 feature that automatically tracks how many parts of your program are using a Container. When the last reference disappears, the memory is freed automatically.</p>

        <p>When you write:</p>

        <pre><code class="language-cpp">
auto sound_container = vega.read_audio("file.wav");
        </code></pre>

        <p>What's actually happening is:</p>

        <pre><code class="language-cpp">
std::shared_ptr<MayaFlux::Kakshya::SoundFileContainer> sound_container =
    /* vega.read_audio() internally creates and returns a shared_ptr */;
        </code></pre>

        <p>You don't see <code>std::shared_ptr</code>. You see <code>auto</code>. But MayaFlux is using it. This means:</p>

        <ul>
            <li><strong>You never manually <code>delete</code> the Container.</strong> It handles itself.</li>
            <li><strong>Multiple parts of your code can reference the same Container</strong> without worrying about who's responsible for cleanup.</li>
            <li><strong>When the last reference is gone</strong>, memory is automatically released.</li>
        </ul>

        <p>This is why <code>vega.read_audio()</code> is safe. The complexity of memory management exists—it's just not your problem.</p>

    </details>


    <h2>Expansion 3: What is <code>vega</code>?</h2>

    <details>
        <summary></summary>

        <p><code>vega</code> is a <strong>fluent interface</strong>—a convenience layer that takes MayaFlux's power and hides the verbosity without hiding the machinery.</p>

        <p>Grappling with complexity generally yields expressive, and often well-reasoned, implementations. However, many find it hard to parse the wall of code that results from such grappling, partly because machine-level languages tend to prioritize other aspects of coding over user experience (UX).</p>

        <p>Making complex logic less verbose can be a good way to encourage more people to explore.</p>

        <p>If you didn't have <code>vega</code>, loading a file would look like this:</p>

        <pre><code class="language-cpp">
// Without vega - explicit, showing every step
auto reader = std::make_unique<MayaFlux::IO::SoundFileReader>();
MayaFlux::IO::SoundFileReader::initialize_ffmpeg();

if (!reader->can_read("file.wav")) {
    std::cerr << "Cannot read file\n";
    return;
}

reader->set_target_sample_rate(MayaFlux::Config::get_sample_rate());
reader->set_target_bit_depth(64);
reader->set_audio_options(MayaFlux::IO::AudioReadOptions::DEINTERLEAVE);

MayaFlux::IO::FileReadOptions options = MayaFlux::IO::FileReadOptions::EXTRACT_METADATA;
if (!reader->open("file.wav", options)) {
        MF_ERROR(Journal::Component::API, Journal::Context::FileIO, "Failed to open file: {}", reader->get_last_error());
    return;
}

auto container = reader->create_container();
auto sound_container = std::dynamic_pointer_cast<Kakshya::SoundFileContainer>(container);

if (!reader->load_into_container(sound_container)) {
        MF_ERROR(Journal::Component::API, Journal::Context::Runtime, "Failed to load audio data: {}", reader->get_last_error());
    return;
}

auto processor = std::dynamic_pointer_cast<Kakshya::ContiguousAccessProcessor>(
    sound_container->get_default_processor());
if (processor) {
    std::vector<uint64_t> output_shape = {
        MayaFlux::Config::get_buffer_size(),
        sound_container->get_num_channels()
    };
    processor->set_output_size(output_shape);
    processor->set_auto_advance(true);
}

// Now you have sound_container
        </code></pre>

        <p>Depending on your exposure to programming, this can either feel complex or liberating. Lacking the facilities to be explicit about memory management or allocation can be limiting:</p>
        <ul>
            <li>Not knowing when memory is created, bound, or cleared</li>
            <li>Realizing too late that your memory usage is exceeding the budget</li>
            <li>Slowing the system for the false simplicity of "available without effort"</li>
        </ul>
        <p>These often lead to confinement and confusion.</p>

        <p>However, the above code snippet is verbose for something so simple.</p>

        <p><code>vega</code> says: "You just want to load a file? Say so."</p>

        <pre><code class="language-cpp">
auto sound_container = vega.read_audio("file.wav");
        </code></pre>

        <p>Same machinery underneath. Same FFmpeg integration. Same resampling. Same deinterleaving. Same processor setup. Same safety.</p>

        <p><strong>What <code>vega</code> does:</strong></p>
        <ul>
            <li>Infers format from filename extension</li>
            <li>Initializes the reader with sensible defaults</li>
            <li>Handles error checking internally</li>
            <li>Constructs the Container correctly</li>
            <li>Configures the processor</li>
            <li>Returns the result</li>
        </ul>

        <p><strong>What <code>vega</code> doesn't do:</strong></p>
        <ul>
            <li>Hide the complexity. It subsumes the <em>verbosity</em>, not the <em>idea</em>.</li>
            <li>Make the Container less capable. It's the full Container with all features.</li>
            <li>Remove your ability to do this explicitly. You can always write the long version if you need control.</li>
        </ul>

        <p>The short syntax is convenience. The long syntax is control. MayaFlux gives you both.</p>

        <p><strong>Use <code>vega</code> because you value fluency, not because you fear the machinery.</strong></p>

    </details>


    <h2>Expansion 4: The Container's Processor</h2>

    <details>
        <summary></summary>

        <p>The Container you just created isn't just a data holder. It has a <strong>default processor</strong>—a piece of machinery attached to it that knows how to feed data to buffers.</p>

        <p>This processor (<code>ContiguousAccessProcessor</code>) does crucial work:</p>

        <ol>
            <li><strong>Understands the memory layout</strong> - how the Container's audio data is organized</li>
            <li><strong>Knows the buffer size</strong> - how many samples to chunk at a time (typically 512 or 4096)</li>
            <li><strong>Tracks position</strong> - where in the file you are (auto-advance means it moves forward each time data is requested)</li>
            <li><strong>Deinterleaves access</strong> - gives channels separately (crucial for processing, as you can transform each channel independently)</li>
        </ol>

        <p>When you later connect this Container to buffers (in the next section), the processor is what actually feeds the data—it's the active mechanism.</p>

        <p><code>vega.read_audio()</code> configures this processor automatically:</p>

        <ul>
            <li>Sets output size to your project's buffer size</li>
            <li>Enables auto-advance (keeps moving through the file)</li>
            <li>Registers it with the Container</li>
        </ul>

        <p>This is why <code>StreamContainers</code> (that <code>SoundFileContainer</code> inherits from) are more than data—they're <em>active</em>, with built-in logic for how they should be consumed.</p>

    </details>


    <h2>Expansion 5: What <code>.read_audio()</code> Does NOT Do</h2>

    <details>
        <summary></summary>

        <p>This is important:</p>

        <p><strong><code>.read_audio()</code> does NOT:</strong></p>
        <ul>
            <li>Start playback</li>
            <li>Create buffers</li>
            <li>Connect to your audio hardware</li>
            <li>Route data anywhere</li>
        </ul>

        <p><strong><code>.read_audio()</code> DOES:</strong></p>
        <ul>
            <li>Read file from disk</li>
            <li>Decode audio (handle any format: WAV, MP3, FLAC, etc. via FFmpeg)</li>
            <li>Resample to your project's sample rate</li>
            <li>Convert precision</li>
            <li>Deinterleave channels</li>
            <li>Allocate memory for all samples</li>
            <li>Attach a processor that knows how to access this data</li>
            <li>Return you a Container</li>
        </ul>

        <p>The Container sits in memory, ready to be used. But "ready to be used" means <strong>you</strong> decide what happens next: process it, analyze it, route it to output or visual processing, feed it into a machine-learning pipeline, anything.</p>

        <p><strong>That's the power of this design</strong>: loading is separate from routing. You can load a file and immediately send it to hardware, or spend the next 20 lines building a complex processing pipeline before ever playing it.</p>

    </details>

    <hr>

    <p>In the next section, we'll connect this Container to buffers and route it to your speakers. And you'll see why this two-step design—load, then connect—is more powerful than one-step automatic playback.</p>

</section>

<!-- =======================  TUTORIAL SECTION 2 ======================= -->

<section class="tutorial-section">

    <div class="tutorial-row">

        <div class="tutorial-card" data-target="second-expanded">
            <h3 class="tutorial-title">Tutorial: Connect to Buffers</h3>
            <p class="hint">Click this card to reveal full explanation</p>

            <h4>The Next Step</h4>
            
            <p>You have a Container loaded. Now you need to send it somewhere.</p>

            <pre><code class="language-cpp">
auto sound_container = vega.read_audio("path/to/file.wav");
auto buffers = MayaFlux::hook_sound_container_to_buffers(sound_container);
            </code></pre>

            <p>Run this code. Your file plays.</p>

            <p>The Container + the hook call—together they form the path from disk to speakers. This section shows you what that connection does.</p>
        </div>

    </div>

</section>


<!-- =======================  EXPANSION SECTION 2 ======================= -->

<section id="second-expanded" class="tutorial-expanded">

    <h2>Expansion 1: What Are Buffers?</h2>

    <details>
        <summary>Click to expand: Understanding Buffers</summary>

        <p>A <strong>Buffer</strong> is a temporal accumulator—a space where data gathers until it's ready to be released, then it resets and gathers again.</p>

        <p>Buffers don't store your entire file. They store chunks. At your project's sample rate (48 kHz), a typical buffer might hold 512 or 4096 samples: a handful of milliseconds of audio.</p>

        <p>Here's why this matters:</p>

        <p>Your audio interface (speakers, headphones) has a fixed callback rate. It says: "Give me 512 samples of audio, and do it every 10 milliseconds. Repeat forever until playback stops."</p>

        <p>Buffers are the industry standard method to meet this demand.</p>

        <ol>
            <li><strong>Gathers</strong> - accumulates samples from your Container (via its processor)</li>
            <li><strong>Holds</strong> - keeps those samples temporarily</li>
            <li><strong>Releases</strong> - sends them to hardware</li>
            <li><strong>Resets</strong> - becomes empty and ready for the next chunk</li>
        </ol>

        <p>This cycle repeats thousands of times per minute. Buffers make that possible.</p>

        <p>Without buffers, you'd have to manually manage these chunks yourself. With buffers, MayaFlux handles the cycle. Your Container's processor feeds data into them. The buffers exhale it to your ears.</p>

    </details>


    <h2>Expansion 2: Why Per-Channel Buffers?</h2>

    <details>
        <summary>Click to expand: Stereo, Mono, and Channel Architecture</summary>

        <p>A stereo file has 2 channels. A multichannel file might have 4 or 8 channels. MayaFlux doesn't merge them into one buffer.</p>

        <p>Instead, it creates <strong>one buffer per channel</strong>.</p>

        <p>Why? Because channels are independent processing domains. A stereo file's left channel and right channel:</p>

        <ul>
            <li>Can be processed differently</li>
            <li>Can be routed to different outputs</li>
            <li>Can have different process chains</li>
            <li>Can be analyzed separately</li>
            <li>Can coordinate with each other without conflict</li>
        </ul>

        <p>When you hook a stereo Container to buffers, MayaFlux creates:</p>

        <ul>
            <li>Buffer for channel 0 (left)</li>
            <li>Buffer for channel 1 (right)</li>
        </ul>

        <p>Each buffer:</p>

        <ul>
            <li>Pulls samples from the Container's channel 0 or channel 1 (via the Container's processor)</li>
            <li>Gets filled with 512/4096/etc. samples</li>
            <li>Sends those samples to the audio interface's corresponding output</li>
        </ul>

        <p>This per-channel design is why you can later insert processing on a per-channel basis. Insert a filter on channel 0? The first channel gets filtered. Leave channel 1 alone? The second channel plays unprocessed. This flexibility is only possible because channels are architecturally separate at the buffer level.</p>

    </details>


    <h2>Expansion 3: The Buffer Manager and Buffer Lifecycle</h2>

    <details>
        <summary>Click to expand: How Buffers Are Created and Managed</summary>

        <p>MayaFlux has a <strong>buffer manager</strong>—a central system that creates, tracks, and coordinates all buffers in your program.</p>

        <p>When you call <code>hook_sound_container_to_buffers()</code>, here's what happens:</p>

        <pre><code class="language-cpp">
auto buffer_manager = MayaFlux::get_buffer_manager();
uint32_t num_channels = container->get_num_channels();

for (uint32_t channel = 0; channel < num_channels; ++channel) {
    auto container_buffer = buffer_manager->create_audio_buffer<ContainerBuffer>(
        ProcessingToken::AUDIO_BACKEND,
        channel,
        container,
        channel);
    container_buffer->initialize();
}
        </code></pre>

        <p>Step by step:</p>

        <ol>
            <li><strong>Get the buffer manager</strong> - a global system that owns all buffers</li>
            <li><strong>Ask the Container: how many channels?</strong> - determines the loop count</li>
            <li><strong>For each channel:</strong>
                <ul>
                    <li>Create an audio buffer of type <code>ContainerBuffer</code> (a buffer that reads from a Container)</li>
                    <li>Tag it with <code>AUDIO_BACKEND</code> (more on this in Expansion 5)</li>
                    <li>Tell it which channel matrix the buffer should belong to</li>
                    <li>Tell it which channel in the Container to read from</li>
                    <li>Initialize it (prepare it for the callback cycle)</li>
                </ul>
            </li>
        </ol>

        <p>Now the buffer manager knows:</p>

        <ul>
            <li>These buffers exist</li>
            <li>These buffers are tied to this Container</li>
            <li>These buffers should feed the audio hardware</li>
            <li>These buffers are ready to cycle</li>
        </ul>

        <p>When the audio callback fires (every 10ms at 48 kHz), the buffer manager wakes up all its <code>AUDIO_BACKEND</code> buffers and says: "Time for the next chunk. Fill yourselves."</p>

        <p>Each buffer asks its Container's processor: "Give me 512 samples from your channel."</p>

        <p>The processor pulls from the Container, advances its position, and hands back a chunk.</p>

        <p>The buffer receives it and passes it to the audio interface.</p>

        <p>Repeat forever.</p>

    </details>


    <h2>Expansion 4: ContainerBuffer—The Bridge</h2>

    <details>
        <summary>Click to expand: How Buffers Know Their Source</summary>

        <p>You created a <code>ContainerBuffer</code>, not just a generic <code>Buffer</code>. Why the distinction?</p>

        <p>A <strong>Buffer</strong> is abstract—it's a temporal accumulator. But abstract things don't know where their data comes from.</p>

        <p>A <strong>ContainerBuffer</strong> is specific—it's a buffer that knows:</p>

        <ul>
            <li>"My data comes from a Container"</li>
            <li>"My Container has a processor that chunks data"</li>
            <li>"I ask that processor for samples from a specific channel"</li>
        </ul>

        <p>When the callback fires, the ContainerBuffer doesn't generate samples. It asks: "Container, give me the next 512 samples from your channel 0."</p>

        <p>The Container's processor (remember <code>ContiguousAccessProcessor</code> from Section 1?) handles this. It:</p>

        <ul>
            <li>Knows where in the file you are (it tracks position)</li>
            <li>Knows how much data to chunk (512 samples)</li>
            <li>Pulls that many samples from its memory</li>
            <li>Auto-advances (moves the position forward)</li>
            <li>Returns the chunk</li>
        </ul>

        <p>The ContainerBuffer receives it. Done.</p>

        <p>This is the architecture: <strong>Buffers don't generate or transform. They request and relay.</strong> The Container's processor does the work. The buffer coordinates timing with hardware.</p>

        <p>Later, when you add processing nodes or attach processing chains, you'll insert them between the Container's output and the buffer's input. The buffer still doesn't transform—it still just relays. But what it relays will have been processed first.</p>

    </details>


    <h2>Expansion 5: Processing Token—AUDIO_BACKEND</h2>

    <details>
        <summary>Click to expand: Tokens, Domains, and Hardware Destinations</summary>

        <p>In the buffer creation code:</p>

        <pre><code class="language-cpp">
auto container_buffer = buffer_manager->create_audio_buffer<ContainerBuffer>(
    ProcessingToken::AUDIO_BACKEND,
    channel,
    container,
    channel);
        </code></pre>

        <p>Notice <code>ProcessingToken::AUDIO_BACKEND</code>. This is a <strong>token</strong>—a semantic marker that tells MayaFlux:</p>

        <ul>
            <li><strong>This buffer is audio-domain</strong> (not graphics, not compute)</li>
            <li><strong>This buffer is connected to the hardware backend</strong> (it's the final destination before speakers)</li>
            <li><strong>This buffer runs at audio callback rate</strong> (every ~10ms at 48 kHz, every 512 samples)</li>
            <li><strong>This buffer synchronizes with the real-time audio clock</strong></li>
        </ul>

        <p>Tokens are how MayaFlux coordinates different processing domains without confusion. Later, you might have:</p>

        <ul>
            <li><code>AUDIO_BACKEND</code> buffers - connected to speakers (hardware real-time)</li>
            <li><code>AUDIO_PARALLEL</code> buffers - internal processing (process chains, analysis, etc.)</li>
            <li><code>GRAPHICS_BACKEND</code> buffers - visual domain (frame-rate, not sample-rate)</li>
        </ul>

        <p>Each token tells the system what timing, synchronization, and backend this buffer belongs to.</p>

        <p>For now: <code>AUDIO_BACKEND</code> means "this buffer is feeding your ears directly. It must keep real-time pace with the audio interface."</p>

    </details>


    <h2>Expansion 6: Accessing the Buffers</h2>

    <details>
        <summary>Click to expand: What You Can Do With the Buffers</summary>

        <p>When you call <code>vega.read_audio() | Audio</code>, MayaFlux creates the buffers internally. But now, with the ability to get those buffers back, you have access to them:</p>

        <pre><code class="language-cpp">
auto sound_container = vega.read_audio("path/to/file.wav");
auto buffers = MayaFlux::get_last_created_container_buffers();

// Now you have the buffers as a vector:
// buffers[0] → channel 0
// buffers[1] → channel 1 (if stereo)
// etc.
        </code></pre>

        <p>Why is this useful? Because buffers own <strong>processing chains</strong>. And processing chains are where you'll insert processes, analysis, transformations - everything that turns passive playback into active processing.</p>

        <p>Each buffer has a method:</p>

        <pre><code class="language-cpp">
auto chain = buffers[0]->get_processing_chain();
        </code></pre>

        <p>This gives you access to the chain that currently handles that buffer's data. Right now, the chain just reads from the Container and writes to the hardware. But you can modify that chain.</p>

        <ul>
            <li>Add processors.</li>
            <li>Analyze data.</li>
            <li>Route to different destinations.</li>
        </ul>

        <p>This is the foundation for Section 3. You load a file, get the buffers, access their chains, and inject processing into those chains.</p>

    </details>


    <h2>The Fluent vs. Explicit Comparison</h2>

    <h3>Fluent (What happens behind the scenes)</h3>

    <pre><code class="language-cpp">
vega.read_audio("path/to/file.wav") | Audio;
    </code></pre>

    <p>This single line does all of the above: creates a Container, creates per-channel buffers, hooks them to the audio hardware, and starts playback. No file plays until the <code>| Audio</code> operator, which is when the connection happens.</p>

    <h3>Explicit (What's actually happening)</h3>

    <pre><code class="language-cpp">
auto sound_container = vega.read_audio("path/to/file.wav");
auto buffers = MayaFlux::get_last_created_container_buffers();
// File is loaded, buffers exist, but no connection to hardware yet
// Buffers have chains, but nothing is using them

// To actually play, you'd need to ensure they're registered
// (vega.read_audio() | Audio does this automatically)
    </code></pre>

    <p><strong>Understanding the difference:</strong></p>

    <ul>
        <li>The fluent version (<code>| Audio</code>) triggers buffer creation <em>and</em> hardware connection</li>
        <li>The explicit version gives you the buffers so you can inspect and modify them <em>before</em> hooking to hardware</li>
        <li>Both do the same thing—one is convenience, one is control</li>
    </ul>

    <hr>

<div class="tutorial-card" style="margin-top: 2rem;">
    <h2 class="tutorial-title">Try It → Recap</h2>
    <p class="hint">Click this card for recap + runnable example</p>

    <pre><code class="language-cpp">
void compose() {
    vega.read_audio("path/to/your/file.wav") | Audio;
}
    </code></pre>

    <p>Replace <code>"path/to/your/file.wav"</code> with an actual path.</p>

    <h3>What You Achieved</h3>

    <p>You have:</p>

    <ul>
        <li>A Container loaded with all audio data (deinterleaved, resampled, ready)</li>
        <li>Per-channel buffers created, each tied to a Container channel</li>
        <li>Buffers registered with the buffer manager and audio interface</li>
        <li>The callback cycle running, continuously pulling chunks and feeding them to speakers</li>
        <li>Your file plays start-to-finish automatically</li>
    </ul>

    <p>No code running during playback—just the callback cycle doing its work, thousands of times per minute.</p>

    <p>In the next section, we'll modify these buffers' processing chains. We'll insert a filter processor and hear how it changes the sound. This is where MayaFlux's power truly shines—transforming passive playback into active, real-time audio processing.</p>

</section>

<!-- =======================  TUTORIAL SECTION 3 ======================= -->

<section class="tutorial-section">

    <div class="tutorial-row">

        <div class="tutorial-card" data-target="third-expanded">
            <h3 class="tutorial-title">Tutorial: Buffers Own Chains</h3>
            <p class="hint">Click this card to reveal full explanation</p>

            <h4>The Simplest Path</h4>
            
            <p>You have buffers. You can modify what flows through them.</p>

            <pre><code class="language-cpp">
auto sound_container = vega.read_audio("path/to/file.wav") | Audio;
auto buffers = MayaFlux::get_last_created_container_buffers();

auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
auto filter_processor = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
            </code></pre>

            <p>Run this code. Your file plays with a low-pass filter applied.</p>

            <p>The filter smooths the audio—reduces high frequencies. Listen to the difference.</p>

            <p>That's it. Three lines of code: load, get buffers, insert filter. The rest of this section shows you what just happened.</p>
        </div>

    </div>

</section>


<!-- =======================  EXPANSION SECTION 3 ======================= -->

<section id="third-expanded" class="tutorial-expanded">

    <h2>Expansion 1: What Is <code>vega.IIR()</code>?</h2>

    <details>
        <summary>Click to expand: Creating Filter Nodes</summary>

        <p><code>vega.IIR()</code> creates a filter node—a computation unit that processes audio samples one at a time.</p>

        <p>An <strong>IIR filter</strong> (Infinite Impulse Response) is a mathematical operation that transforms samples based on feedback coefficients. The two parameters are:</p>

        <ul>
            <li><strong>Feedforward coefficients</strong> <code>{0.1, 0.2, 0.1}</code> - how the current and past input samples contribute</li>
            <li><strong>Feedback coefficients</strong> <code>{1.0, -0.6}</code> - how past output samples contribute</li>
        </ul>

        <p>You don't need to understand the math. Just know: this creates a filter that smooths audio.</p>

        <p><code>vega</code> is the fluent interface—it subsumes verbosity. Without it:</p>

        <pre><code class="language-cpp">
// Without vega - explicit
auto filter = std::make_shared<Nodes::Filters::IIR>(
    std::vector<double>{0.1, 0.2, 0.1},
    std::vector<double>{1.0, -0.6}
);
        </code></pre>

        <p>With vega:</p>

        <pre><code class="language-cpp">
auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
        </code></pre>

        <p>Same filter. Same capabilities. Vega just hides the verbosity.</p>

    </details>


    <h2>Expansion 2: What Is <code>MayaFlux::create_processor()</code>?</h2>

    <details>
        <summary>Click to expand: Wrapping Nodes in Processors</summary>

        <p>A <strong>node</strong> (like <code>vega.IIR()</code>) is a computational unit—it processes one sample at a time.</p>

        <p>A <strong>processor</strong> is a buffer-aware wrapper around that node. It knows:</p>

        <ul>
            <li>How to extract data from a buffer</li>
            <li>How to feed samples to the node</li>
            <li>How to put the transformed samples back in the buffer</li>
            <li>How to handle the buffer's processing cycle</li>
        </ul>

        <p><code>create_processor()</code> wraps your filter node in a processor and attaches it to a buffer's processing chain.</p>

        <pre><code class="language-cpp">
auto filter_processor = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
        </code></pre>

        <p>What this does:</p>

        <ol>
            <li>Takes your filter node</li>
            <li>Creates a <code>FilterProcessor</code> that knows how to apply that node to buffer data</li>
            <li>Adds the processor to <code>buffers[0]</code>'s processing chain (implicit—this happens automatically)</li>
            <li>Returns the processor so you can reference it later if needed</li>
        </ol>

        <p>The buffer now has this processor in its chain. Each cycle, the buffer runs the processor, which applies the filter to all samples in that cycle.</p>

    </details>


    <h2>Expansion 3: What Is a Processing Chain?</h2>

    <details>
        <summary>Click to expand: How Buffers Execute Processors</summary>

        <p>Each buffer owns a <strong>processing chain</strong>—an ordered sequence of processors that transform data.</p>

        <p>Your buffer's default processor was:</p>

        <ul>
            <li><strong>ContainerToBufferAdapter</strong> - reads from the Container, fills the buffer</li>
        </ul>

        <p>When <code>create_processor()</code> adds your FilterProcessor, the chain becomes:</p>

        <ol>
            <li>Default processor: ContainerToBufferAdapter (reads from Container)</li>
            <li><strong>FilterProcessor</strong> (applies your filter) ← You just added this</li>
            <li>Other processors you might add later (e.g., Writer to send to hardware)</li>
        </ol>

        <p>Each cycle:</p>

        <ul>
            <li>Adapter fills the buffer with 512 samples from the Container</li>
            <li>FilterProcessor runs—modifies those 512 samples by applying the filter</li>
            <li>Other processors run in sequence</li>
        </ul>

        <p>Data flows: <strong>Container → [filtered] → Speakers</strong></p>

        <p>The chain is ordered. Processors run in sequence. Output of one becomes input to next.</p>

    </details>


    <h2>Expansion 4: Adding Processor to Another Channel (Optional)</h2>

    <details>
        <summary>Click to expand: Multi-Channel Processing</summary>

        <p>Your stereo file has two channels. Right now, only channel 0 is filtered.</p>

        <p>You can add the same processor to channel 1:</p>

        <pre><code class="language-cpp">
auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
auto fp0 = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
auto fp1 = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[1], filter);
        </code></pre>

        <p>Or more simply, add the existing processor to another buffer:</p>

        <pre><code class="language-cpp">
auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
auto filter_processor = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
MayaFlux::add_processor(filter_processor, buffers[1], MayaFlux::Buffers::ProcessingToken::AUDIO_BACKEND);
        </code></pre>

        <p><code>add_processor()</code> adds an existing processor to a buffer's chain.</p>

        <p><code>create_processor()</code> creates a processor and adds it implicitly.</p>

        <p>Both do the same underlying thing—they add the processor to the buffer's chain. <code>create_processor()</code> just combines creation and addition in one call.</p>

        <p>Now both channels are filtered by the same IIR node. Different channel buffers can share the same processor or have independent ones—your choice.</p>

    </details>


    <h2>Expansion 5: What Happens Inside</h2>

    <details>
        <summary>Click to expand: The Machinery Under the Hood</summary>

        <p>When you call:</p>

        <pre><code class="language-cpp">
auto filter_processor = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
        </code></pre>

        <p>MayaFlux does this:</p>

        <pre><code class="language-cpp">
// 1. Create a new FilterProcessor wrapping your filter node
auto processor = std::make_shared<MayaFlux::Buffers::FilterProcessor>(filter);

// 2. Get the buffer's processing chain
auto chain = buffers[0]->get_processing_chain();

// 3. Add the processor to the chain
chain->add_processor(processor, buffers[0]);

// 4. Return the processor
return processor;
        </code></pre>

        <p>When <code>add_processor()</code> is called separately:</p>

        <pre><code class="language-cpp">
MayaFlux::add_processor(filter_processor, buffers[1], MayaFlux::Buffers::ProcessingToken::AUDIO_BACKEND);
        </code></pre>

        <p>MayaFlux does this:</p>

        <pre><code class="language-cpp">
// Get the buffer manager
auto buffer_manager = MayaFlux::get_buffer_manager();

// Get channel 1's buffer for AUDIO_BACKEND token
auto buffer = buffer_manager->get_buffer(ProcessingToken::AUDIO_BACKEND, 1);

// Get its processing chain
auto chain = buffer->get_processing_chain();

// Add the processor
chain->add_processor(processor, buffer);
        </code></pre>

        <p>The machinery is consistent: <strong>processors are added to chains, chains are owned by buffers, buffers execute chains each cycle.</strong></p>

        <p>You don't need to write this explicitly—the convenience functions handle it. But this is what's happening.</p>

    </details>


    <h2>Expansion 6: Processors Are Reusable Building Blocks</h2>

    <details>
        <summary>Click to expand: Composition and Flexibility</summary>

        <p>A processor is a building block. Once created, it can be:</p>

        <ul>
            <li>Added to multiple buffers (same processor, multiple channels)</li>
            <li>Composed with other processors (insert multiple processors)</li>
            <li>Swapped out (remove and replace)</li>
            <li>Queried (ask for its state, parameters, etc.)</li>
        </ul>

        <p>Example: two channels with the same filter:</p>

        <pre><code class="language-cpp">
auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
auto processor = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
MayaFlux::add_processor(processor, buffers[1]);
        </code></pre>

        <p>Example: stacking processors (requires understanding of chains, shown later):</p>

        <pre><code class="language-cpp">
auto filter1 = vega.IIR(...);
auto fp1 = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter1);

auto filter2 = vega.IIR(...); // Different filter
auto fp2 = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter2);
        </code></pre>

        <p>Now <code>buffers[0]</code> has two FilterProcessors in its chain. Data flows through both sequentially.</p>

        <p>Processors are the creative atoms of MayaFlux. Everything builds from them.</p>

    </details>

    <hr>

    <div class="tutorial-card" style="margin-top: 2rem;">
        <h2 class="tutorial-title">Try It → Recap</h2>
        <p class="hint">Click this card for recap + runnable example</p>

        <pre><code class="language-cpp">
void compose() {
    auto sound_container = vega.read_audio("path/to/your/file.wav") | Audio;
    auto buffers = MayaFlux::get_last_created_container_buffers();

    auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
    auto filter_processor = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
}
        </code></pre>

        <p>Replace <code>"path/to/your/file.wav"</code> with an actual path.</p>

        <p>Run the program. Listen. The audio is filtered.</p>

        <p>Now try modifying the coefficients:</p>

        <pre><code class="language-cpp">
auto filter = vega.IIR(std::vector{0.05, 0.3, 0.05}, std::vector{1.0, -0.8});
        </code></pre>

        <p>Listen again. Different sound. You're sculpting the filter response.</p>

        <h3>What You Achieved</h3>

        <p>You've just inserted a processor into a buffer's chain and heard the result. That's the foundation for everything that follows.</p>

        <p>In the next section, we'll interrupt this passive playback. We'll insert a processing node between the Container and the buffers. And you'll see why this architecture—buffers as relays, not generators—enables powerful real-time transformation.</p>

        <p>For a comprehensive tutorial on buffer processors and related concepts, visit the <a href="./ProcessingExpression.md">Buffer Processors Tutorial</a>.</p>
    </div>

</section>

<!-- =======================  TUTORIAL SECTION 4 ======================= -->

<section class="tutorial-section">

    <div class="tutorial-row">

        <div class="tutorial-card" data-target="fourth-expanded">
            <h3 class="tutorial-title">Tutorial: Timing, Streams, and Bridges</h3>
            <p class="hint">Click this card to reveal full explanation</p>

            <h4>The Current Continous Flow</h4>
            
            <p>What you've done so far is simple and powerful:</p>

            <pre><code class="language-cpp">
auto sound_container = vega.read_audio("path/to/file.wav") | Audio;
auto buffers = MayaFlux::get_last_created_container_buffers();
auto filter = vega.IIR(std::vector{0.1, 0.2, 0.1}, std::vector{1.0, -0.6});
auto fp = MayaFlux::create_processor<MayaFlux::Buffers::FilterProcessor>(buffers[0], filter);
            </code></pre>

            <p>This flow is designed for <strong>full-file playback</strong>:</p>

            <ul>
                <li>Load the entire file into a Container</li>
                <li>Route it through buffers</li>
                <li>Add general purpose processes</li>
                <li>Play to speakers (RtAudio backend via SubsystemManagers)</li>
            </ul>

            <p>Clean. Direct. No timing control.</p>

            <p>That's intentional.</p>

            <p>There are other features—region looping, seeking, playback control, but they don't fit this tutorial. These sections are purely for: <strong>file → buffers → output, uninterrupted.</strong></p>
        </div>

    </div>

</section>


<!-- =======================  EXPANSION SECTION 4 ======================= -->

<section id="fourth-expanded" class="tutorial-expanded">

    <h2>Where We're Going</h2>

    <p>Here's what the next section enables:</p>

    <pre><code class="language-cpp">
auto pipeline = MayaFlux::create_buffer_pipeline();
pipeline->with_strategy(ExecutionStrategy::PHASED); // Execute each phase fully before next op

pipeline
    >> BufferOperation::capture_file_from("path/to/file.wav", 0)  // From channel 0
    .for_cycles(20)  // Process 20 buffer cycles
    >> BufferOperation::transform([](auto& data, uint32_t cycle) {
        // Data now has 20 buffer cycles of audio from the file
        // i.e 20 x 512 samples if buffer size is 512
        auto zero_crossings = MayaFlux::zero_crossings(data);

        std::cout << "Zero crossings at indices:\n";
        for (const auto& sample : zero_crossings) {
            std::cout << sample << "\t";
        }
        std::cout << "\n";

        return data;
    });

pipeline->execute_buffer_rate();  // Schedule and run
    </code></pre>

    <p>This processes exactly 20 buffer cycles from the file (with any process you want), accumulates the result in a stream, and executes the pipeline.</p>

    <p>The file isn't playing to speakers. It's being captured, processed, and stored in a stream. <strong>Timing is under your control.</strong> You decide how many buffer cycles to process. This section builds the foundation for buffer pipelines. Understanding the architecture below explains why the code snippet works.</p>

    <p>In this section, we will introduce the machinery for everything beyond simplicity. We're not building code that has audio yet. We're establishing the architecture that enables timing control, streaming, capture, and composition.</p>

    <h2>Expansion 1: The Architecture of Containers</h2>

    <details>
        <summary>Click to expand: Why We Need Something Else</summary>

        <p>A Container (like SoundFileContainer) holds all data upfront:</p>

        <ul>
            <li>Load entire file into memory</li>
            <li>Data is fixed size</li>
            <li>Processor knows where in the file you are</li>
            <li>Designed for sequential access—read start, advance, read next chunk, repeat until end</li>
        </ul>

        <p>This works perfectly for "play the whole file". It also works for as yet unexplored controls over the same timeline, such as looping, seeking positions, jumping to regions, etc.</p>

        <p>But it doesn't work for:</p>

        <ul>
            <li><strong>Recording</strong>: You don't know the final size upfront</li>
            <li><strong>Structuring</strong>: You need to manipulate boundaries</li>
            <li><strong>Streaming</strong>: Data arrives in chunks; size grows dynamically</li>
            <li><strong>Capture</strong>: You want to save specific buffer cycles, not the whole file</li>
        </ul>

        <p>For these use cases, you need a different data structure.</p>

    </details>


    <h2>Expansion 2: Enter DynamicSoundStream</h2>

    <details>
        <summary>Click to expand: A Container That Grows</summary>

        <p>A <strong>DynamicSoundStream</strong> is a child class of <code>SignalSourceContainer</code> much like <code>SoundFileContainer</code> that we have been using. It has the same interface as <code>SoundFileContainer</code> (channels, frames, metadata, regions). But it has different semantics:</p>

        <ul>
            <li><strong>Dynamic size</strong>: Starts small, grows as data arrives</li>
            <li><strong>Transient modes</strong>: Can operate as a circular buffer (fixed size, overwrites old data)</li>
            <li><strong>Sequential writing</strong>: Designed to accept data sequentially from processors</li>
            <li><strong>No inherent structure</strong>: Unlike SoundFileContainer (which knows "this is a file with a start and end"), DynamicSoundStream is just a growing reservoir of data.</li>
        </ul>

        <p>Think of it as:</p>

        <ul>
            <li><strong>SoundFileContainer</strong>: "I am this exact file, with this exact data"</li>
            <li><strong>DynamicSoundStream</strong>: "I am a space where audio data accumulates. I don't know how much will arrive."</li>
        </ul>

        <p>DynamicSoundStream has powerful capabilities:</p>

        <ul>
            <li><strong>Auto-resize mode</strong>: Grows as data arrives (good for recording)</li>
            <li><strong>Circular mode</strong>: Fixed capacity, wraps around (good for delay lines or rolling analysis)</li>
            <li><strong>Position tracking</strong>: Knows where reads/writes are in the stream</li>
            <li><strong>Capacity pre-allocation</strong>: You can reserve space if you know approximate size</li>
        </ul>

        <p>You don't create DynamicSoundStream directly (yet). It's managed implicitly by other systems. But understanding what it is explains everything that follows.</p>

    </details>


    <h2>Expansion 3: StreamWriteProcessor</h2>

    <details>
        <summary>Click to expand: Writing Buffer Data to Streams</summary>

        <p>You've seen <code>BufferProcessors</code> like <code>FilterProcessor</code> that transform data in place.</p>

        <p>But <code>StreamWriteProcessor</code> is more general. It can write buffer data to <strong>any</strong> <code>DynamicSoundStream</code>, not just locally to attached buffers (or from hardware: hitherto unexplored <code>InputListenerProcessor</code>).</p>

        <p>When a processor runs each buffer cycle:</p>

        <ol>
            <li>Buffer gets filled with 512 samples (from Container or elsewhere)</li>
            <li>Processors run (your <code>FilterProcessor</code>, for example)</li>
            <li><code>StreamWriteProcessor</code> writes the (now-processed) samples to a <code>DynamicSoundStream</code></li>
        </ol>

        <p>The <code>DynamicSoundStream</code> accumulates these writes:</p>

        <ul>
            <li>Cycle 1: 512 samples written</li>
            <li>Cycle 2: Next 512 samples written (total: 1024)</li>
            <li>Cycle 3: Next 512 samples written (total: 1536)</li>
            <li>...</li>
        </ul>

        <p>After N cycles, the <code>DynamicSoundStream</code> contains N × 512 samples of processed audio.</p>

        <p>This is how you capture buffer data. Not by sampling the buffer once, by continuously writing it to a stream through a processor.</p>

        <p><code>StreamWriteProcessor</code> is the bridge between buffers (which live in real-time) and streams (which accumulate).</p>

    </details>


    <h2>Expansion 4: FileBridgeBuffer—Controlled Flow</h2>

    <details>
        <summary>Click to expand: The Reading-Writing Bridge</summary>

        <p><strong>FileBridgeBuffer</strong> is a specialized buffer that orchestrates reading from a file and writing to a stream, with timing control through buffer cycles.</p>

        <p>Internally, FileBridgeBuffer creates a processing chain:</p>

        <pre><code class="language-text">
SoundFileContainer (source file)
    ↓
ContainerToBufferAdapter (reads from file, advances position)
    ↓
[Your processors here: filters, etc.]
    ↓
StreamWriteProcessor (writes to internal DynamicSoundStream)
    ↓
DynamicSoundStream (accumulates output)
        </code></pre>

        <p>The key difference from your simple load/play flow:</p>

        <ul>
            <li>Instead of routing to hardware, data goes to a DynamicSoundStream</li>
            <li>You control <strong>how many buffer cycles</strong> run (e.g., "process 10 cycles of this file")</li>
            <li>After N cycles, the stream holds N × buffer_size samples of the processed result</li>
        </ul>

        <p>FileBridgeBuffer represents: <strong>"Read from this file, process through this chain, accumulate result in this stream, for exactly this many cycles."</strong></p>

        <p>This gives you timing control. You don't play the whole file. You process exactly N cycles, then stop.</p>

    </details>


    <h2>Expansion 5: Why This Architecture?</h2>

    <details>
        <summary>Click to expand: Decoupling Reading, Processing, and Output</summary>

        <p>The architecture separates concerns:</p>

        <ul>
            <li><strong>Reading</strong>: Done by ContainerToBufferAdapter (reads from SoundFileContainer in controlled chunks)</li>
            <li><strong>Processing</strong>: Done by your custom processors</li>
            <li><strong>Writing</strong>: Done by StreamWriteProcessor (writes results to DynamicSoundStream)</li>
            <li><strong>Accumulation</strong>: Done by DynamicSoundStream (holds the result)</li>
        </ul>

        <p>Each layer is independent:</p>

        <ul>
            <li>You can swap the reader (use a different Container)</li>
            <li>You can insert any number of processors</li>
            <li>You can swap the writer (write to hardware, to disk, to memory, to GPU)</li>
            <li>The stream is just a data holder—it doesn't care what filled it</li>
        </ul>

        <p>This is why FileBridgeBuffer is powerful: it composes these layers without forcing you to wire them manually.</p>

        <p>And it's why understanding this section matters: <strong>the next tutorial (BufferOperation) builds on top of this composition</strong>, adding temporal coordination and pipeline semantics.</p>

    </details>


    <h2>Expansion 6: From File to Cycle</h2>

    <details>
        <summary>Click to expand: "Cycles" as Timing Units</summary>

        <p>A <strong>cycle</strong> is one complete buffer processing round:</p>

        <ul>
            <li>512 samples from the source</li>
            <li>Processed through all processors</li>
            <li>Written to the destination stream</li>
        </ul>

        <p>At 48 kHz, one cycle is 512 ÷ 48000 ≈ 10.67 milliseconds of audio.</p>

        <p>When you say "process this file for 20 cycles," you mean:</p>

        <ul>
            <li>Run 20 iterations of: read 512 → process → write 512</li>
            <li>Result: 10,240 samples (≈ 213 ms of audio at 48 kHz)</li>
        </ul>

        <p>Timing control is expressed in <strong>cycles</strong>, not time. This is intentional:</p>

        <ul>
            <li>Cycles are deterministic (you know exactly how much data will be processed)</li>
            <li>Cycles are aligned with buffer boundaries (no partial processing)</li>
            <li>Cycles decouple from hardware timing (no real-time constraints)</li>
        </ul>

        <p>FileBridgeBuffer lets you say: "Process this file for exactly N cycles," then accumulate the result in a stream.</p>

        <p>This is the foundation for everything BufferOperation does—it extends this cycle-based thinking to composition and coordination.</p>

    </details>

    <hr>

    <h2>The Three Key Concepts</h2>

    <p>At this point, understand:</p>

    <ol>
        <li><strong>DynamicSoundStream</strong>: A container that grows dynamically, can operate in circular mode, designed to accumulate data from processors</li>
        <li><strong>StreamWriteProcessor</strong>: The processor that writes buffer data sequentially to a DynamicSoundStream</li>
        <li><strong>FileBridgeBuffer</strong>: A buffer that creates a chain (reader → your processors → writer), and lets you control how many buffer cycles run</li>
    </ol>

    <p>These three concepts enable timing control. You're no longer at the mercy of real-time callbacks. You can process exactly N cycles, accumulate results, and move on.</p>

    <hr>

    <div class="tutorial-card" style="margin-top: 2rem;">
        <h2 class="tutorial-title">Why This Section Has No Audio Code</h2>
        
        <p>This is intentional. The concepts here are essential, and expose the architecture behind everything that follows. It is also a hint at the fact that modal output is not the only use case for MayaFlux.</p>

        <ul>
            <li>FileBridgeBuffer is too low-level—you'd create it manually, call setup_chain_and_processor(), manage cycles yourself</li>
            <li>DynamicSoundStream is too generic—without a driver, you'd just accumulate data with no purpose</li>
            <li>StreamWriteProcessor is just a piece—alone, it doesn't tell you how many cycles to run</li>
        </ul>

        <p>The <strong>next tutorial introduces BufferOperation</strong>, which wraps these concepts into high-level, composable patterns:</p>

        <ul>
            <li><code>BufferOperation::capture_file()</code> - wrap FileBridgeBuffer, accumulate N cycles, return the stream</li>
            <li><code>BufferOperation::file_to_stream()</code> - connect file reading to stream writing, with cycle control</li>
            <li><code>BufferOperation::route_to_container()</code> - send processor output to a stream</li>
        </ul>

        <p>Once you understand FileBridgeBuffer, DynamicSoundStream, and cycle-based timing, BufferOperation will feel natural. It's just syntactic sugar on top of this architecture.</p>

        <p>For now: <strong>internalize the architecture. The next section shows how to use it.</strong></p>

        <h3>What You Should Internalize</h3>

        <ul>
            <li>Containers hold data (SoundFileContainer holds files; DynamicSoundStream holds growing data)</li>
            <li>Processors transform data (your FilterProcessor, StreamWriteProcessor, etc.)</li>
            <li>Buffers orchestrate cycles (read N cycles, run processors, write results)</li>
            <li>Streams accumulate (DynamicSoundStream holds results after cycles complete)</li>
            <li>Timing is expressed in cycles (deterministic, aligned with buffer boundaries, decoupled from real-time)</li>
        </ul>

        <p>This is the mental model for everything that follows. Pipelines, capture, routing—they all build on this foundation.</p>
    </div>

</section>

<!-- =======================  TUTORIAL SECTION 5 ======================= -->

<section class="tutorial-section">

    <div class="tutorial-row">

        <div class="tutorial-card" data-target="fifth-expanded">
        <h2 class="tutorial-title">Tutorial: Buffer Pipelines (Teaser)</h2>
        <p class="hint">Click this card to reveal full explanation</p>

            <pre><code class="language-cpp">
        void compose() {
            // Create an empty audio buffer (will hold captured data)
            auto capture_buffer = vega.AudioBuffer()[1] | Audio;
            // Create a pipeline
            auto pipeline = MayaFlux::create_buffer_pipeline();
            // Set strategy to streaming (process as data arrives)
            pipeline->with_strategy(ExecutionStrategy::STREAMING);

            // Declare the flow:
            pipeline
                >> BufferOperation::capture_file_from("path/to/audio/.wav", 0)
                    .for_cycles(1) // Essential for streaming
                >> BufferOperation::route_to_buffer(capture_buffer) // Route captured data to our buffer
                >> BufferOperation::modify_buffer(capture_buffer, [](std::shared_ptr<AudioBuffer> buffer) {
                    for (auto& sample : buffer->get_data()) {
                        sample *= MayaFlux::get_uniform_random(-0.5, 0.5); // random "texture" between 0 and 0.5
                    }
                });

            // Execute: runs continuously at buffer rate
            pipeline->execute_buffer_rate();
        }
            </code></pre>

            <p>Run this. You'll hear the file play back with noisy texture. But the file never played to speakers directly: it was captured, processed, accumulated, then routed.</p>

        </div>

    </div>

</section>


<!-- =======================  EXPANSION SECTION 5 ======================= -->

<section id="fifth-expanded" class="tutorial-expanded">

    <h3>The Next Level</h3>
    
    <p>Everything you've learned so far processes data in isolation: load a file, add a processor, output to hardware.</p>

    <p>But what if you want to:</p>

    <ul>
        <li><strong>Capture</strong> a specific number of buffer cycles from a file</li>
        <li><strong>Process</strong> those cycles through custom logic</li>
        <li><strong>Route</strong> the result to a buffer for playback</li>
        <li><strong>Do all of this in one declarative statement</strong></li>
    </ul>

    <p>That's what buffer pipelines do.</p>

    <h2>Expansion 1: What Is a Pipeline?</h2>

    <details>
        <summary>Click to expand: Declarative Processing Chains</summary>

        <p>A <strong>pipeline</strong> is a declarative sequence of buffer operations that compose to form a complete computational event.</p>

        <p>Unlike the previous sections where you manually:</p>

        <ol>
            <li>Load a file</li>
            <li>Get buffers</li>
            <li>Create processors</li>
            <li>Add to chains</li>
        </ol>

        <p>...a pipeline lets you describe the entire flow in one statement:</p>

        <pre><code class="language-cpp">
pipeline
    >> Operation1
    >> Operation2
    >> Operation3;
        </code></pre>

        <p>The <code>>></code> operator chains operations. The pipeline executes them in order, handling all the machinery (cycles, buffer management, timing) invisibly.</p>

        <p>This is why you've been learning the foundation first: <strong>pipelines are just syntactic sugar over FileBridgeBuffer, DynamicSoundStream, StreamWriteProcessor, and buffer cycles.</strong></p>

        <p>Understanding the previous sections makes this section obvious. You're not learning new concepts—you're composing concepts you already understand.</p>

    </details>


    <h2>Expansion 2: BufferOperation Types</h2>

    <details>
        <summary>Click to expand: What Operations Exist</summary>

        <p>BufferOperation is a toolkit. Common operations:</p>

        <ul>
            <li><strong>capture_file()</strong> - Read N cycles from a file, accumulate in internal stream</li>
            <li><strong>modify_buffer()</strong> - Apply custom logic to a specific AudioBuffer</li>
            <li><strong>route_to_buffer()</strong> - Send accumulated result to an AudioBuffer for playback</li>
            <li><strong>route_to_container()</strong> - Send result to a DynamicSoundStream (for recording, analysis, etc.)</li>
            <li><strong>transform()</strong> - Map/reduce on accumulated data (structural transformation)</li>
            <li><strong>dispatch()</strong> - Execute arbitrary code with access to the data</li>
        </ul>

        <p>Each operation is a building block. Pipeline chains them together.</p>

        <p>The full set of operations is the subject of its own tutorial. This section just shows the pattern.</p>

    </details>


    <h2>Expansion 3: The <code>on_capture_processing</code> Pattern</h2>

    <details>
        <summary>Click to expand: Processing Each Cycle</summary>

        <p>Notice in the example:</p>

        <pre><code class="language-cpp">
>> BufferOperation::modify([](auto& data, uint32_t cycle) {
    // Called every cycle as data accumulates
    for (auto& sample : data) {
        sample *= 0.5;
    }
})
        </code></pre>

        <p>The <code>modify</code> operation runs <strong>each cycle</strong>—meaning:</p>

        <ul>
            <li>Cycle 1: 512 samples captured, modified by your lambda</li>
            <li>Cycle 2: Next 512 samples captured, modified</li>
            <li>Cycle 3: And so on</li>
        </ul>

        <p>This is <code>on_capture_processing</code>: your custom logic runs as data arrives, not automated by external managers.</p>

        <p>Automatic mode simply expects buffer manager to handle the processing of attached processors. On Demand mode expects users to provide callback timing logic.</p>

        <p>For now: understand that pipelines let you hook custom logic into the capture/process/route flow.</p>

    </details>


    <h2>Expansion 4: Why This Matters</h2>

    <details>
        <summary>Click to expand: Composability and Control</summary>

        <p>Before pipelines, your workflow was:</p>

        <ol>
            <li>Load file (Container)</li>
            <li>Get buffers</li>
            <li>Add processors to buffers</li>
            <li>Play to hardware</li>
            <li>Everything was real-time</li>
        </ol>

        <p>With pipelines, your workflow is:</p>

        <ol>
            <li>Declare capture (file, cycle count)</li>
            <li>Declare processing (what to do each cycle)</li>
            <li>Declare output (where result goes)</li>
            <li>Execute (all at once, deterministic, no real-time constraints)</li>
        </ol>

        <p>The key difference: <strong>determinism</strong>. You know exactly what will happen because you've declared the entire flow.</p>

        <p>This is the foundation for everything beyond this tutorial:</p>

        <ul>
            <li>Recording sessions</li>
            <li>Batch processing</li>
            <li>Data analysis pipelines</li>
            <li>Complex temporal arrangements</li>
            <li>Multi-file composition</li>
        </ul>

        <p>All of it starts with this pattern: <strong>declare → execute → observe</strong>.</p>

    </details>

    <hr>

    <div class="tutorial-card" style="margin-top: 2rem;">
        <h2 class="tutorial-title">What Happens Next</h2>
        
        <p>The full <strong>Buffer Pipelines</strong> tutorial is its own comprehensive guide. It covers:</p>

        <ul>
            <li>All BufferOperation types</li>
            <li>Composition patterns (chaining operations)</li>
            <li>Timing and cycle coordination</li>
            <li>Error handling and introspection</li>
            <li>Advanced patterns (branching, conditional operations, etc.)</li>
        </ul>

        <p>This section is just the proof-of-concept: "Here's what becomes possible when everything you've learned composes."</p>

        <hr>

        <h3>Try It (Optional)</h3>

        <p>The code above will run if you have:</p>

        <ul>
            <li>A <code>.wav</code> file at <code>"path/to/file.wav"</code></li>
            <li>All the machinery from Sections 1-3 understood</li>
        </ul>

        <p>If you want to experiment, use a real file path and run it.</p>

        <p>But the main point is: <strong>understand what's happening</strong>, not just make it work.</p>

        <ul>
            <li>You're capturing from a file</li>
            <li>Each cycle, your lambda processes 512 samples</li>
            <li>Results accumulate in capture_buffer</li>
            <li>Then capture_buffer plays to hardware</li>
        </ul>

        <p>This is real composition. Not playback. Not presets. Declarative data transformation.</p>

        <hr>

    </div>

</section>


        <h3>The Philosophy</h3>

        <p>You've now seen the complete stack:</p>

        <ol>
            <li><strong>Containers</strong> hold data (load files)</li>
            <li><strong>Buffers</strong> coordinate cycles (chunk processing)</li>
            <li><strong>Processors</strong> transform data (effects, analysis)</li>
            <li><strong>Chains</strong> order processors (sequence operations)</li>
            <li><strong>Pipelines</strong> compose chains (declare complete flows)</li>
        </ol>

        <p>Each layer builds on the previous. None is magic. All are composable.</p>

        <p>This is how MayaFlux thinks about computation: as layered, declarative, composable building blocks.</p>

        <p>Pipelines are where that thinking becomes powerful. They're not a special feature—they're just the final layer of composition.</p>

        <hr>

        <h3>Next: The Full Pipeline Tutorial</h3>

        <p>When you're ready, the standalone <strong>"Buffer Pipelines"</strong> tutorial dives deep into:</p>

        <ul>
            <li>Every BufferOperation type with examples</li>
            <li>How to compose complex workflows</li>
            <li>Error handling and debugging</li>
            <li>Performance considerations</li>
            <li>Real-world use cases</li>
        </ul>

        <p>For now: you've seen the teaser. Everything you've learned so far is the foundation for that depth.</p>

        <p>You understand how information flows. Pipelines just let you declare that flow elegantly.</p>

<script>
    document.querySelectorAll(".tutorial-card").forEach(card => {
        card.addEventListener("click", () => {
            const target = document.getElementById(card.dataset.target);
            if (!target) return;
            target.style.display = (target.style.display === "block") ? "none" : "block";
        });
    });
</script>
